# /stan plan

Start or continue the PLAN phase.

## Instructions

1. Check preconditions:
   - `stan.md` exists?
   - PRD `status: approved`?
   - If no: Notify and STOP

2. Check current phase:
   - If DEFINE: Switch to PLAN (normal)
   - If PLAN: Continue
   - If CREATE: **Push back!**
     ```
     Currently in CREATE phase!

     Going back to PLAN means:
     - Pausing implementation
     - Potentially defining new tasks

     Reason for going back?
     ```

3. If in PLAN phase:
   - Check if plan exists (`docs/plan.md`)
   - If no: Derive plan from PRD
   - If yes: Check plan status

4. Plan creation (JSONL-based):
   - Read PRD and identify tasks
   - **Apply Story Size Rule** (see below)
   - For each task, use `task_schema.py`:
     ```python
     from task_schema import create_task

     task = create_task(
         subject="Task description",
         description="Detailed description (2-3 sentences)",
         phase="create",  # or "define", "plan"
         dependencies=["t-xxxx"],  # IDs of dependent tasks
         acceptance_criteria=["AC1", "AC2", "Verify in browser"],
     )
     # Returns task with auto-generated hash ID (t-xxxx)
     ```
   - For UI tasks: Add "Verify in browser" to acceptance_criteria
   - Set dependencies between tasks

5. After tasks created, regenerate markdown:
   ```python
   from task_generator import regenerate_tasks_md
   regenerate_tasks_md()  # Updates docs/tasks.md from JSONL
   ```

6. After plan creation:
   - Run criteria checks
   - If all required=true are met: At least 1 task should be `status: pending` with no blockers (= ready)

7. When tasks are ready:
   ```
   [STAN] Plan ready!

   Tasks: {count}
   Ready to start: {ready_count}

   View tasks: /stan ready
   Start work: /stan create
   ```

## Task ID Format

Tasks use **hash-based IDs** (not sequential):
- Format: `t-xxxx` (4-6 hex characters)
- Auto-generated by `create_task()`
- Collision-free across worktrees
- Example: `t-a1b2`, `t-f3e4d5`

**Why hash IDs?**
- No collisions when parallel worktrees create tasks
- No need for coordination/locking
- Shorter and easier to reference

## Story Size Rule

**Each task must be completable in ONE iteration (one context window).**

### Right-sized tasks:
- Add a database column and migration
- Add a UI component to an existing page
- Update a server action with new logic
- Add a filter dropdown to a list

### Too big (split these):
- "Build the entire dashboard" → Split into: schema, queries, UI components, filters
- "Add authentication" → Split into: schema, middleware, login UI, session handling
- "Refactor the API" → Split into one task per endpoint

**Rule of thumb:** If you cannot describe the change in 2-3 sentences, it is too big.

### Task Ordering

Tasks must be ordered by dependency:
1. Schema/database changes (migrations)
2. Server actions / backend logic
3. UI components that use the backend
4. Dashboard/summary views that aggregate data

## Important

- Tasks should be concrete and actionable
- Dependencies MUST be complete
- Each task must fit in one iteration
- For UI tasks, include "Verify in browser" in criteria
- Parallelization only where SAFE
